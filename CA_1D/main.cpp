// generated by Fast Light User Interface Designer (fluid) version 1.0304

#include "main.h"
#include <FL/Fl_Image.H>
#include <cmath>

Fl_Double_Window *window_main=(Fl_Double_Window *)0;

Fl_Value_Input *input_size=(Fl_Value_Input *)0;

Fl_Value_Input *input_iterations=(Fl_Value_Input *)0;

Fl_Value_Input *input_rule=(Fl_Value_Input *)0;

Fl_Button *btn_run=(Fl_Button *)0;

Fl_Box *result=(Fl_Box *)0;

int main() {
  { window_main = new Fl_Double_Window(380, 240, "1D Automats");
    { input_size = new Fl_Value_Input(40, 16, 32, 32, "Size:");
    } // Fl_Value_Input* input_size
    { input_iterations = new Fl_Value_Input(160, 16, 32, 32, "Iterations:");
    } // Fl_Value_Input* input_iterations
    { input_rule = new Fl_Value_Input(240, 16, 32, 32, "Rule:");
    } // Fl_Value_Input* input_rule
    { btn_run = new Fl_Button(288, 16, 80, 32, "Run");
      btn_run->callback((Fl_Callback*)callback_run);
    } // Fl_Button* btn_run
    { result = new Fl_Box(0, 56, 380, 184);
      result->box(FL_FLAT_BOX);
      result->color(FL_BACKGROUND2_COLOR);
    } // Fl_Box* result
    window_main->size_range(380, 240, 380, 240);
    window_main->end();
  } // Fl_Double_Window* window_main
  window_main->show();
    return Fl::run();
}

void callback_run() {
  int x,y;
    if(input_size->value()>=380)
    x=input_size->value();
    else x=380;
    if(input_iterations->value()>=184)
    y=input_iterations->value();
    else y=184;
    result->resize(0,56,input_size->value(),input_iterations->value());
    window_main->resize(window_main->x_root(),window_main->y_root(),x,y+56);
    draw_image(result,input_size->value(),input_iterations->value(),input_rule->value());
    window_main->redraw();
}

int* solve_rule(int rule) {
  int w=7;
    int* outcome=new int[8];
    for(int i=0;i<8;i++){
      if(pow(2,w)<=rule){
        rule-=pow(2,w);
        outcome[i]=1;
      }
      else outcome[i]=0;
      w--;
    }
    return outcome;
}

int to_decimal(int bin) {
  int outcome=0;
    int w=0;
    while(bin>0){
      outcome+=bin%10*pow(2,w);
      bin/=10;
      w++;
    }
    return outcome;
}

void draw_image(Fl_Box* canvas, int size, int iterations,int rule) {
  int* ruleArray=solve_rule(rule);
    int* space=new int[size];
  
    int** outcome=new int*[iterations];
    for(int i=0;i<iterations;i++)
      outcome[i]=new int[size];
  
    for(int i=0;i<size;i++)
      outcome[0][i]=0;
    outcome[0][size/2]=1;
    for(int i=1;i<iterations;i++)
      for(int j=0;j<size;j++){
        int bin=100*outcome[i-1][(j+size-1)%size]+10*outcome[i-1][j]+outcome[i-1][(j+1)%size];
        int dec=to_decimal(bin);
        outcome[i][j]=ruleArray[7-dec];
      }
  
    unsigned char* image_data=new unsigned char[size*iterations*4];
    for(int i=0;i<iterations;i++)
      for(int j=0;j<size;j++){
        if(outcome[i][j]==1){
          image_data[(i*size+j)*4]=0;
          image_data[(i*size+j)*4+1]=0;
          image_data[(i*size+j)*4+2]=0;
        }
        else{
          image_data[(i*size+j)*4]=255;
          image_data[(i*size+j)*4+1]=255;
          image_data[(i*size+j)*4+2]=255;
        }
        image_data[(i*size+j)*4+3]=255;
      }
    Fl_Image *image=new Fl_RGB_Image(image_data,size,iterations,4,0);
    result->image(image);
}
